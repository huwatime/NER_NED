// Copyright 2019, University of Freiburg,
// Chair of Algorithms and Data Structures.
// Yi-Chun Lin <circle40191@gmail.com>

#include <fstream>
#include <unordered_map>
#include <set>
#include <stdlib.h>
#include "utils.hpp"

using std::cout;
unsigned int seed = time(NULL);

inline string getRandomLine(std::ifstream& f, const std::set<uint64_t>& ids) {
  uint64_t lineId;
  string line;
  std::streampos pos;

  f.seekg(0, f.end);
  pos = f.tellg();

  while (true) {
    pos = pos * (1.0 * rand_r(&seed) / RAND_MAX);

    f.seekg(pos);
    std::getline(f, line);  // The first line may be incomplete
    std::getline(f, line);
    lineId = stoi(tokenlize(line, '\t')[0]);

    if (ids.find(lineId) == ids.end()) {
      break;
    }
  }

  return line;
}

/*
 * Generate clueweb IOB file with wikidata_id for NER_NED, by
 * replacing freebase_id in input IOB file, using the mapping given.
 */
void genCluewebWikidataIOB(const string& inFile, const string& mapFile,
    const uint64_t targetSize, const string& outFile) {
  std::ifstream fIn(inFile.c_str());
  std::ifstream fMap(mapFile.c_str());
  std::ofstream fOut(outFile.c_str());

  string line;
  std::size_t pos;
  std::set<uint64_t> lineIds;

  std::unordered_map<string, string> idMapping;
  vector<string> idList;
  string wikidataId, freebaseId;

  cout << "Loading id mapping file...\n";
  // Line format: <http://www.wikidata.org/entity/xxx>,"/m/xxx"
  while (std::getline(fMap, line)) {
    idList = tokenlize(line, ',');
    pos = idList.size() == 2 ? idList[1].rfind("/") : string::npos;

    if (idList.size() != 2 ||
        idList[0].size() < 34 ||
        idList[1].size() < 4 ||
        pos == std::string::npos) {
      continue;
    }

    idList[0].erase(idList[0].end() - 1);
    idList[1].erase(idList[1].end() - 1);
    idList[1].replace(pos, 1, ".");
    wikidataId = idList[0].substr(32);
    freebaseId = idList[1].substr(2);
    idMapping[freebaseId] = wikidataId;
  }

  cout << "Replacing ids...\n";
  while (lineIds.size() < targetSize) {
    printProgress(lineIds.size(), targetSize);
    bool valid = true;
    vector<string> lineFields;
    vector<string> textList;

    line = getRandomLine(fIn, lineIds);
    lineFields = tokenlize(line, '\t');
    textList = tokenlize(lineFields[1], ' ');

    if (textList[0].substr(0, 3) == "[m.") {
      continue;
    }

    for (auto& text : textList) {
      if ((pos = text.rfind("\\")) == string::npos) {
        valid = false;
        break;
      }

      freebaseId = text.substr(pos+1);
      if (freebaseId == "I" || freebaseId == "O") {
        continue;
      }

      if (idMapping.find(freebaseId) == idMapping.end()) {
        valid = false;
        break;
      }
      wikidataId = idMapping[freebaseId];
      text.replace(pos+1, string::npos, wikidataId);
    }

    if (valid) {
      string lineId = lineFields[0];
      fOut << lineId << '\t' << join(textList, ' ') << '\n';
      lineIds.insert(atoll(lineId.c_str()));
    }
  }

  fIn.close();
  fMap.close();
  fOut.close();
}

int main(int argc, char** argv) {
  if (argc < 4) {
    cout << "\nUsage: \n" <<
    "  gen_clueweb_wikidata_iob_main <clueweb-freebase-iob-annotations> "
    "<id_mapping_csv> <size>\n" <<
    "\nDescription: \n" <<
    "  Generate <size> lines of wikidata annoations, by randomly selecting "<<
    "sentences in <clueweb-freebase-iob-annotations> and replacing " <<
    "freebase_id with wikidata_id using the given id mapping file.\n\n" <<
    "  <clueweb_freebase_iob_file> \n" <<
    "    generated by gen_clueweb_freebase_iob_main\n\n" <<
    "  <id_mapping_csv> \n" <<
    "    mappings between freebase and wikidata IDs,\n" <<
    "    generated by qLever at http://qlever.informatik.uni-freiburg.de/"
    "Wikidata_Full\n" <<
    "    of line format <http://www.wikidata.org/entity/xxx>,\"/m/xxx\"\n\n"<<
    "  <size> \n" <<
    "    the number of sentences to generate\n\n";
    return 1;
  }

  string outputPath = argv[1];
  std::size_t found = outputPath.rfind("freebase");
  if (found != string::npos) {
    outputPath.replace(found, 8, "wikidata");
  } else {
    outputPath += ".wikidata";
  }
  outputPath += ".random" + string(argv[3]);
  cout << "\nOutput path: " << outputPath << "\n";

  genCluewebWikidataIOB(argv[1], argv[2], atoll(argv[3]), outputPath);
  cout << "\nDone!\n\n";
  return 0;
}


